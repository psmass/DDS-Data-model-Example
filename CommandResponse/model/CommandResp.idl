/*  Commands below are 'short-lived' meaning they are responded to immediately and 
	     don't require Objective State. 

         This example will have a Controller and a Device (where there could be many devices).
	     The Device will announce itself with a Device Announcement (DA) topic. It will  use
	     a QoS of Durable, then wait to be commanded.
	     The Controller will recognize the device and issue a command to TURN_ON. 
	     Controller will then periodically request status.  There is a one-to-one
	     correspondence between Controller Commands and Device Responses. That is for 
	     these two commands, TOPIC_REQUEST_CONFIGURE_DEVICE, and TOPIC_REQUEST_DEVICE_STATUS,
	     the Device will respond with TOPIC_DEVICE_CONFIGURATON_REPLY and TOPIC_DEVICE_STATUS_REPLY.

         The Device will filter for "myCommands" (i.e., on targetDeviceID), the Controller
	     does not filter since it may expect key'd responses from many deviceIDs.

         To keep things simple the device
	     will not issue Alarms or any other non-requested topics except the intial DA.

       */
module ExCmdRsp {
  /* Start_Header_File_Const-Block 
       These Constants are defined here as part of the system model and used to generate a header file where they can be used 
       from a .cxx file. Unfortunately they cannot also be used within this XML file itself
       */
  const string MODULE_EX_CMD_RSP = "ExCmdRsp";

  const string TOPIC_CONFIGURE_DEVICE = "ConfigureDevice";

  const string TOPIC_DEVICE_STATE = "DeviceState";

  const string CONTROLLER1_PARTICIPANT = "CmdRspParticipantLibrary::ControllerParticipant1";

  const string DEVICE1_PARTICIPANT = "CmdRspParticipantLibrary::DeviceParticipant1";

  const string DEVICE_STATE_WRITER = "DevicePublisher::DeviceStateWriter";

  const string DEVICE_STATE_READER = "ControllerSubscriber::DeviceStateReader";

  const string CONFIGURE_DEVICE_WRITER = "ControllerPublisher::ConfigureDeviceWriter";

  const string CONFIGURE_DEVICE_READER = "DeviceSubscriber::ConfigureDeviceReader";

  /* End_Header_File_Const_Block */
  const uint32 LEN_DEVICE_ID = 32;

  const uint32 LEN_STR_FOO = 10;

  const uint32 LEN_STR_BAR = 16;

  enum DeviceStateEnum {
    UNINITIALIZED,
    OFF,
    ON,
    ERROR
  };

  @nested
  struct DeviceId {
    int32 resourceId;
    int32 id;
  };

  @nested
  struct DeviceConfigurationStuct {
    ExCmdRsp::DeviceStateEnum stateReq;
    string<LEN_STR_FOO> fooName;
    int32 fooValue;
    string<LEN_STR_BAR> barName;
    uint32 barValue;
  };

  typedef ExCmdRsp::DeviceConfigurationStuct DeviceConfiguration;

  struct ConfigureDevice {
    DeviceId targetDeviceId;
    ExCmdRsp::DeviceConfiguration deviceConfig;
  };

  struct DeviceState {
    @key
    DeviceId myDeviceId;
    ExCmdRsp::DeviceStateEnum state;
  };

};
